import argparse
import logging
import os
from multiprocessing import Process
from os.path import join
from threading import Condition, Lock
from typing import NamedTuple, Sequence, Mapping, Any

import pkg_resources
import yaml

from hhd.plugins import Config
from hhd.plugins.settings import Container, HHDSettings, Mode, Setting

from .logging import setup_logger
from .plugins import Config, Emitter, Event, HHDAutodetect, HHDPlugin
from .plugins.settings import merge_settings, parse_settings
from .utils import Context, expanduser, get_context

logger = logging.getLogger(__name__)

CONFIG_DIR = os.environ.get("HHD_CONFIG_DIR", "~/.config/hhd")

ERROR_DELAY = 5


def generate_desc(s: Setting | Container | Mode):
    desc = f"*{s['title']}*\n"
    if h := s.get("hint", None):
        line = ""
        for token in h.split(" "):
            if len(line) + len(token) > 80:
                desc += f"{line}\n"
                line = ""
            line += f"{token} "
        if line:
            desc += f"{line}\n"

    match s["type"]:
        case "mode":
            desc += f"- modes: [{', '.join(map(str, s['modes']))}]\n"
        case "number":
            desc += f"- numerical: ["
            desc += f"{s['min'] if s.get('min', None) is not None else '-inf'}, "
            desc += f"{s['max'] if s.get('max', None) is not None else '+inf'}]\n"
        case "bool":
            desc += f"- boolean: [False, True]\n"
        case "multiple" | "discrete":
            desc += f"- options: [{', '.join(map(str, s['options']))}]\n"

    if (d := s.get("default", None)) is not None:
        desc += f"- default: {d}\n"
    return desc[:-1]


def traverse_desc(set: Setting | Container | Mode, prev: Sequence[str]):
    out = []
    out.append(
        (
            prev,
            generate_desc(set),
            max(len(prev) - 1, 0),
            set["type"] in ("mode", "container"),
        )
    )
    match set["type"]:
        case "container":
            for child_name, child in set["children"].items():
                out.extend(traverse_desc(child, [*prev, child_name]))
        case "mode":
            for mode_name, mode in set["modes"].items():
                out.extend(traverse_desc(mode, [*prev, mode_name]))
    return out


def tranverse_desc_sec(set: HHDSettings):
    out = []
    for sec_name, sec in set.items():
        for cont_name, cnt in sec.items():
            out.extend(traverse_desc(cnt, [sec_name, cont_name]))
    return out


def dump_comment(set: HHDSettings):
    from hhd import RASTER

    out = "#\n#  "
    out += "\n#  ".join(RASTER.split("\n"))
    out += (
        "\n"
        + "# Handheld Daemon State Config\n"
        + "#\n"
        + "# This file contains plugin software-only configuration that will be retained\n"
        + "# across reboots. You may edit this file in lueu of using a frontend.\n"
        + "#\n"
        + "# Parameters that are stored in hardware (TDP, RGB colors, etc) and\n"
        + "# risky parameters that might cause instability and should be reset\n"
        + "# across sessions are not part of this file.\n"
        + "# Use profiles to apply changes to those.\n"
        + "#\n"
        + "# Persisted (software) parameters are marked by having a default value.\n"
        + "# Non-persisted/hardware parameters do not have a default value.\n"
        + "#\n"
        + "# This file and comments are autogenerated. Your comments will be discarded\n"
        + "# during configuration changes. Parameters with the value `default` are\n"
        + "# ignored and are meant as a template for you to change them.\n"
        + "#\n"
        + "# - CONFIGURATION PARAMETERS\n"
        + "#"
    )
    descs = tranverse_desc_sec(set)
    for i, (path, desc, ofs, is_container) in enumerate(descs):
        out += f"\n# {'│' * max((ofs - 1), 0)}┌> {'.'.join(path)}\n# {'│' * ofs} "
        lines = desc.split("\n")
        out += ("\n# " + "│" * ofs + " ").join(lines[:-1])

        next_ofs = descs[i + 1][2] if i < len(descs) - 1 else 0
        if not is_container:
            next_ofs -= 1
        next_ofs = max(min(next_ofs, ofs), 0)
        out += f"\n# {'│' * next_ofs}{'└' * (ofs - next_ofs)} {lines[-1]}"
        out += f"\n# {'│' * next_ofs}"
    out += "\n\n"
    return out


def dump_setting(set: Container | Mode, prev: Sequence[str], conf: Config):
    """Finds the current settings that are set to a default value and swaps them
    for the value `default`. For settings without a default value (temporary),
    it sets them to None to avoid setting them."""
    match set["type"]:
        case "container":
            out = {}
            for child_name, child in set["children"].items():
                match child["type"]:
                    case "container" | "mode":
                        s = dump_setting(child, [*prev, child_name], conf)
                        if s:
                            out[child_name] = s
                    case _:
                        m = conf.get([*prev, child_name], None)
                        # Skip writing default values
                        default = child.get("default", None)
                        if default is None:
                            out[child_name] = None
                        elif m is None or default == m:
                            out[child_name] = "default"
            return out
        case "mode":
            out = {}
            m = conf.get([*prev, "mode"], None)
            # Skip writing default values
            default = set.get("default", None)
            if default is None:
                out["mode"] = None
            elif m is None or default == m:
                out["mode"] = "default"

            for mode_name, mode in set["modes"].items():
                s = dump_setting(mode, [*prev, mode_name], conf)
                if s:
                    out[mode_name] = s
            return out


def merge_dicts(a: Mapping | Any, b: Mapping | Any):
    if isinstance(a, Mapping) and isinstance(b, Mapping):
        out = dict(a)
        for k, v in b.items():
            out[k] = merge_dicts(out.get(k, None), v)
    elif isinstance(b, Mapping):
        out = {}
        for k, v in b.items():
            out[k] = merge_dicts(None, v)
    else:
        return b

    for k in list(out.keys()):
        if out[k] is None:
            del out[k]
    if not out:
        return None
    return out


def dump_settings(set: HHDSettings, conf: Config):
    """Fixes default values for settings in set, drops settings without a default value,
    and retains the rest of the configuration, to not mess with plugins that
    were not loaded."""
    out: dict = {"version": 1}
    for sec_name, sec in set.items():
        out[sec_name] = {}
        for cont_name, cnt in sec.items():
            s = dump_setting(cnt, [sec_name, cont_name], conf)
            if s:
                out[sec_name][cont_name] = s

    # Merge dicts to maintain settings for plugins that did not run
    return merge_dicts({"version": 1, **conf.conf}, out)


class EmitHolder(Emitter):
    def __init__(self) -> None:
        self._events = []
        self._lock = Lock()
        self._condition = Condition(self._lock)

    def __call__(self, event: Event | Sequence[Event]) -> None:
        with self._lock:
            if isinstance(event, Sequence):
                self._events.extend(event)
            else:
                self._events.append(event)
            self._condition.notify_all()

    def get_events(self, timeout: int = -1):
        with self._lock:
            if not self._events and timeout != -1:
                self._condition.wait()
            ev = self._events
            self._events = []
            return ev


def write_state(conf: Config, ctx: Context):
    state_fn = expanduser(join(CONFIG_DIR, "state.yml"), ctx)
    with open(state_fn, "w") as f:
        yaml.safe_dump(conf.conf, f)
    os.chown(state_fn, ctx.euid, ctx.egid)


def read_state(ctx: Context):
    state_fn = expanduser(join(CONFIG_DIR, "state.yml"), ctx)
    try:
        with open(state_fn, "r") as f:
            return Config(yaml.safe_load(f))
    except FileNotFoundError:
        logger.info("State file not found, default settings will be used.")
        return Config({})


def main(user: str | None = None):
    # Setup temporary logger for permission retrieval
    ctx = get_context(user)
    if not ctx:
        print(f"Could not get user information. Exiting...")
        return

    detectors: dict[str, HHDAutodetect] = {}
    plugins: dict[str, Sequence[HHDPlugin]] = {}
    try:
        setup_logger(join(CONFIG_DIR, "log"), ctx=ctx)

        for autodetect in pkg_resources.iter_entry_points("hhd.plugins"):
            detectors[autodetect.name] = autodetect.resolve()

        logger.info(f"Found plugin providers: {', '.join(list(detectors))}")

        logger.info(f"Running autodetection...")
        for name, autodetect in detectors.items():
            plugins[name] = autodetect([])

        plugin_str = "Loaded the following plugins:"
        for pkg_name, sub_plugins in plugins.items():
            plugin_str += (
                f"\n  - {pkg_name:>15s}: {', '.join(p.name for p in sub_plugins)}"
            )
        logger.info(plugin_str)

        # Get sorted plugins
        sorted_plugins: Sequence[HHDPlugin] = []
        for plugs in plugins.values():
            sorted_plugins.extend(plugs)
        sorted_plugins.sort(key=lambda x: x.priority)

        if not sorted_plugins:
            logger.error(f"No plugins started, exiting...")
            return

        # Open plugins
        emit = EmitHolder()
        for p in sorted_plugins:
            p.open(emit, ctx)

        # Compile initial configuration
        settings = merge_settings([p.settings() for p in sorted_plugins])
        defaults = parse_settings(settings)

        # FIll in default values
        conf = read_state(ctx)
        for k, v in defaults.items():
            if v is not None and k not in conf:
                conf[k] = v

        from rich import get_console

        get_console().print(conf.conf)
        get_console().print(defaults)
        get_console().print(settings)

        return settings, defaults, conf.conf

        # logger.info(f"Monitoring plugin status, and restarting if necessary.")
        # while True:
        #     exited = select.select(list(running_plugins), [], [])[0]
        #     for fd in exited:
        #         pkg_name, plugin, proc = running_plugins.pop(fd)
        #         if not proc.exitcode:
        #             # Plugin exited normally, not restarting
        #             logger.info(f"Plugin '{plugin['name']}' exited normally.")
        #             continue

        #         logger.error(
        #             f"Plugin '{plugin['name']}' crashed. Restarting in {ERROR_DELAY}s."
        #         )
        #         time.sleep(ERROR_DELAY)
        #         proc = launch_plugin(pkg_name, plugin, perms)
        #         if proc:
        #             running_plugins[proc.sentinel] = (pkg_name, plugin, proc)
        #     time.sleep(ERROR_DELAY)
    except KeyboardInterrupt:
        logger.info(
            f"HHD Daemon received KeyboardInterrupt, stopping plugins and exiting."
        )
    finally:
        for plugs in plugins.values():
            for plug in plugs:
                plug.close()


if __name__ == "__main__":
    parser = argparse.ArgumentParser(
        prog="HHD: Handheld Daemon main interface.",
        description="Handheld Daemon is a daemon for managing the quirks inherent in handheld devices.",
    )
    parser.add_argument(
        "-u",
        "--user",
        default=None,
        help="The user whose home directory will be used to store the files (~/.config/hhd).",
        dest="user",
    )
    args = parser.parse_args()
    user = args.user
    main(user)
